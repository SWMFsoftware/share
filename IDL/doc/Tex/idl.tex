%  Copyright (C) 2002 Regents of the University of Michigan, 
%  portions used with permission 
%  For more information, see http://csem.engin.umich.edu/tools/swmf
\documentclass{article}

\title{IDL visualization macros}

\author{G\'abor T\'oth\\{\it University of Michigan}}

\newcommand{\BATSRUS}{BATS-R-US}
\begin{document}

\maketitle

\newpage

\tableofcontents

\newpage

\section{Introduction}

This document describes the use of the IDL macros 
in the {\bf share/IDL/General/} directory.
These macros were originally developed for the Versatile Advection Code,
and modified and improved for \BATSRUS. Since the macros are written
in a rather general manner, they can be used to visualize and analyze all kinds
of model or observational data as long as it can be read. For example
the plot files from the PWOM, IPIC3D2, FLEKS and ALTOR
of the SWMF can also be visualized and analyzed with these macros.
In addition, simple ASCII files (satellite data, trajectory files, etc.)
as well as various lookup tables (for radiative cooling, equation of state etc.)
can be read and visualized. The plot data modified or created in IDL 
can be written into files in the same formats.

\section{IDL path and startup file \label{s-idl-path}}

It is necessary to let IDL know about the existence of the macros.  
You can define the search path for IDL, for example
\begin{verbatim}
setenv IDL_PATH "${HOME}/SWMF/share/IDL/General:<IDL_DEFAULT>"
\end{verbatim}
for the csh or tcsh shell. You can also make IDL to read 
the {\bf idlrc} file automatically upon start up with
\begin{verbatim}
setenv IDL_STARTUP idlrc
\end{verbatim}
These environment settings can be put into your \~{}/.login or \~{}/.cshrc 
files. The above is valid for the csh and tcsh UNIX shells. 

For other UNIX shells (bash, ksh, zsh), use
\begin{verbatim}
export IDL_PATH="${HOME}/BATSRUS/share/IDL/General:<IDL_DEFAULT>"
export IDL_STARTUP=idlrc
\end{verbatim}
in the \~{}/.profile or similar file.

\section{Running IDL \label{s-run-idl}}

If the IDL\_PATH and the IDL\_STARTUP variables are set, simply 
start IDL from the directory where the {\bf *.out} IDL plot files
and the {\bf *.log} logfiles are, e.g.
\begin{verbatim}
cd run/IO2
idl
\end{verbatim}
If IDL\_STARTUP is not set, type
\begin{verbatim}
@idlrc
\end{verbatim}
at the IDL$>$ prompt, so that the commands in the {\bf idlrc} file are
executed: 
the procedures in {\bf procedures.pro, funcdef.pro} and 
{\bf vector.pro} are compiled and 
the script {\bf set\_defaults} is executed to set some
common block variables to their default values. You can customize the startup
of IDL by editing {\bf idlrc}, e.g. you can
compile your own IDL procedures. 

If an error occurs, the code usually returns to the main level, so one
can fix the settings and try again. The corresponds to the default 
setting
\begin{verbatim}
onerror=2
\end{verbatim}
   For debugging purposes, it may be useful to set 
\begin{verbatim}
onerror=0
\end{verbatim}
so that variables can be written out inside the macro where the error
occurred. In this case, or in general if you get trapped by an error 
inside some IDL routine, typing
\begin{verbatim}
retall
\end{verbatim}
will return to the main level. To exit IDL type
\begin{verbatim}
exit
\end{verbatim}
The alternative 'quit' command is also defined for convenience.

\section{Reading a snapshot with read\_data \label{s-readdata}}

To read a snapshot from a file, type at the "IDL$>$" prompt of IDL
\begin{verbatim}
read_data
\end{verbatim}
The procedure will prompt you for the {\bf filename}, 
and it determines the {\bf filetypes} and {\bf npictinfiles}
(the number of snapshots in the file) automatically. Then it asks for
the frame-number {\bf npict} (1, 2,... npictinfiles) 
of the snapshot to be read from the file. When {\bf npictinfiles=1},
the frame number is set to 1 automatically:
\begin{verbatim}
filename(s)   ? example1.out
filetype(s)   = binary
npictinfile(s)=      1
npict=       1
\end{verbatim}
The header of the file is read and echoed on the screen. 
A typical result:
\begin{verbatim}
filename   = cut.outs
filetype   = ascii
headline   = km Mp/cc km/s km/s km/s nT nT nT nPa
it         =       77
time       =       60.360603
gencoord   =        0
ndim       =        1
neqpar     =        5
nw         =        8
nx         =      256
parameters =       1000. 3. 1.66667  0. 0.
coord names= x
var   names= Rho Ux Uy Uz Bx By Bz P
param names= xSI r g cuty cutz
Read x and w
GRID (PLOT_DATA)
                LONG      = Array[256]
\end{verbatim}
At the end, the {\bf x} and {\bf w} variables (containing the coordinates 
and the plot variables respectively) are read from the file. 
Note that IDL, unlike FORTRAN, starts indexing from 0 instead of 1. 
The {\bf GRID} index array is useful for defining
cuts of the computational domain for plotting, see details 
in section~\ref{s-plot-part}. 

After reading the data you can do whatever you want with {\bf x}, {\bf w}, 
and all the other variables 
{\bf headline, it, time, gencoord, ndim, neqpar, nw, nx, eqpar, variables}
defined by the header. 
You can use the {\bf plot\_data} procedure (see section~\ref{s-plot_data}
to get some sophisticated plots or you can use any of the IDL procedures 
directly to examine and/or plot the data, e.g. for 1D data
\begin{verbatim}
print,time,it
print,nx
print,variables
plot,x,w(*,0),xtitle='X [km]',ytitle='Density'
\end{verbatim}
while for unstructured 2D data, for example, use
\begin{verbatim}
contour,w(*,*,2),x(*,*,0),x(*,*,1),/fill,nlevel=30,/irr
oplot,x(*,*,0),x(*,*,1),psym=1,color=0
\end{verbatim}
The first command produces a color plot of the 3rd variable (index 2).
The second command will show the grid points. Another way to plot the
grid points is to use the {\bf plotgrid} procedure as
\begin{verbatim}
plotgrid,x
\end{verbatim}
For structured 2D grid, you can plot the grid lines connecting
the grid points with 
\begin{verbatim}
plotgrid,x,/lines
\end{verbatim}

\section{Transformation of non-regular grid \label{s-transform}}

The file may contain data on a generalized or unstructured 2D grid.
This is signaled by a negative {\bf ndim} in the plotfile 
and by the variable {\bf gencoord=1} in IDL.
A {\bf generalized grid} has the same topology as a regular grid
but the coordinates are not Cartesian. It is a {\it continuouus}
distortion of the original grid. On the other hand, 
{\bf an unstructured grid} has the grid points in an arbitrary
order, therefore the second and third elements of the 
{\bf nx} array are 1. The AMR grids of \BATSRUS\ and AMRVAC are
unstructured, while VAC can produce generalized grids.

The default behavior is to leave the grid in its original form.
This choice saves the time of transformation, and uses the original grid 
and variables, but only some of the plotting modes are available for 
generalized and unstructured grids: contour, contfill, contlabel, contbar,
vector and stream. Others (e.g. surface, tv, tvbar, velovect) are not.
To allow all plotting modes (and cuts across the grid), the data
has to be transformed (interpolated) onto a regular grid.
To achieve that select the 'regular' transformation with
\begin{verbatim}
transform (r=regular/p=polar/u=unpolar/n=none)=none ? r
\end{verbatim}
   The size of the regular grid can be given by setting the {\bf nxreg} array
\begin{verbatim}
nxreg=[100,100]
\end{verbatim}
If {\bf nxreg} is not set, then  the size of the regular grid will be asked
when the data is read with {\bf read\_data} or {\bf animate\_data}:
\begin{verbatim}
Generalized coordinates, dimensions for regular grid
nxreg(0) (use negative sign to limit x)=      100
nxreg(1) (use negative sign to limit y)=      100
\end{verbatim}
With these settings the original {\bf w} array is interpolated to 
a $100\times100$ {\bf wreg} array and the
coordinates for the regular grid {\bf xreg} are also determined. 
You can plot the first variable, usually density, in {\bf wreg} the 
same way as before
\begin{verbatim}
surface,wreg(*,*,0)
\end{verbatim}
It is possible to restrict the transformation to a rectangular
part of the original 2D data by setting the {\bf xreglimits} array
\begin{verbatim}
xreglimits=[-15, -10, 30.5, 10]
\end{verbatim}
Note that the order of the elements is xmin, ymin, xmax, ymax.
Another way to do this is adding a negative sign when prompted for 
nxreg(0) and nxreg(1), e.g.
\begin{verbatim}
nxreg(0) (use negative sign to limit x)? -100
xreglimits(0) (xmin)? -15.
xreglimits(2) (xmax)? 30.5
nxreg(1) (use negative sign to limit y)? -50
xreglimits(1) (ymin)? -10.
xreglimits(3) (ymax)? 10.
\end{verbatim}
Now the $100\times 50$ {\bf xreg} array is limited to the range 
[-15.,30.5] in x, and [-10.,10.] in y, and this is where the {\bf wreg} 
array is defined. 
To return to the default behaviour, which is plotting the whole 
computational domain, set
\begin{verbatim}
xreglimits=0
\end{verbatim}
If the transformation or the transformation parameters are changed,
the {\bf read\_data} or {\bf animate\_data} procedures, which read data from
the disk, will calculate {\bf wreg} with the new tranformation settings
as expected. The {\bf plot\_data} procedure does not do the transformation
by default to speed things up. If the transformation parameters are changed set
\begin{verbatim}
dotransform='y'
\end{verbatim}
to force {\bf plot\_data} to redo the transformation as necessary.
After that you can return to dotransform='n' to save the time of
transformation.

\section{Other grid transformations \label{s-gridtransform}}

The {\bf transform} parameter can be used to perform various
grid transformations by setting it to one of the following values
\begin{verbatim}
n, none    - no tranformation
r, regular - interpolate onto a regular Cartesian grid (previous section)
p, polar   - convert from Cartesian X-Y(-Z) to polar R-Phi(-Z) coordinates
u, unpolar - convert from polar R-Phi(-Z) to Cartesian X-Y(-Z) coordinates
s, sphere  - convert from Cartesian X-Y-Z to spherical R-Theta-Phi coordinates
m, my      - perform the transformation in the {\bf do_my_transform} procedure
\end{verbatim}
The {\bf polar, unpolar, sphere} options are standard geometric
transformations of the coordinates {\bf x} and the vector variables in
{\bf w} to {\bf xreg} and {\bf wreg}. The angles have to be in
radians.  The number of vector variables is read into {\bf nvector}
and the indexes of the first components of these vector variables are
read into the {\bf vectors} array.

The {\bf transform='my'} 
option allows to define an arbitrary grid/data transformation
that has to be implemented into a {\bf do\_my\_transform.pro}
procedure that needs to be compiled as
\begin{verbatim}
.r do_my_transform
\end{verbatim}
The following simple example converts the second and third coordinates 
of 3D data from radians to degrees:
\begin{verbatim}
do_my_transform,ifile,variables,x,w,xreg,wreg,usereg
   if max(x(*,*,*,1:2)) lt 10.0 then $
      x(*,*,*,1:2) = x(*,*,*,1:2)*180/!pi
end
\end{verbatim}
The if statement prevents accidental multiple transformations 
by {\bf plot\_data} or converting coordinates of a file that uses 
degrees to start with.
As the number of arguments indicate, this feature can be used for much more 
complicated transformations too.

\section{Comparison of data \label{s-compare}}

You can read snapshots from up to 10 files for purposes of
comparison. Simply give the filenames separated by spaces:
\begin{verbatim}
set_default_values
read_data
filename(s)   ? example1.out example2.out
filetype(s)   = real4 real4
npictinfile(s)=      21     10
npict?  2
\end{verbatim}
This will read the second snapshots from 'example1.out' and
'example2.out'. You may also use wild card characters 
\begin{verbatim}
  *  ?  [ ]
\end{verbatim}
that are recognized by the Unix 'ls' command, e.g.
\begin{verbatim}
IDL> filename='example[12].out'
IDL> filename='example?.out'
IDL> filename='exampl*.out'
\end{verbatim}
Note that if any wild card character is used then the order of the files will 
be alphabetical. To read different snapshots from different files, use the
{\bf firstpict} array:
\begin{verbatim}
filename='RESULTS/run[12]*/GM/z=0*.outs'
firstpict=[2,5]
read_data
\end{verbatim}
After reading the files with read\_data, 
the coordinates and the conservative variables 
will be put into {\bf x0, x1} and {\bf w0, w1} respectively, however, 
the header information, which is printed for each file onto the screen, 
will be overwritten by the last file read, in this case it will belong to
{\bf example2.out}. The generic {\bf x, w} arrays will also be
filled by the data read from the last file, and this is what 
{\bf plot\_data} plots. If the files contained data on non-regular grid,
and transform='regular' is set, the data will be interpolated into 
the arrays {\bf wreg0} and {\bf wreg1}. 
To compare the two data sets run
\begin{verbatim}
IDL> compare,w0,w1
iw max(|w1-w2|)/max(|w1|+|w2|) sum(|w1-w2|)/sum(|w1|+|w2|)
       0     0.018272938   0.00017745799
       1      0.24608387     0.017349624
       2      0.14307581     0.016188008
       3 wsum=0
       4     0.022624079   0.00022667312
       5     0.014965503   0.00022646554
       6     0.018034518   0.00020733169
       7 wsum=0
\end{verbatim}
or add the wnames array (an optional argument) to get
\begin{verbatim}
IDL> compare,w0,w1,wnames
iw max(|w1-w2|)/max(|w1|+|w2|) sum(|w1-w2|)/sum(|w1|+|w2|)
rho     0.018272938   0.00017745799
mx      0.24608387     0.017349624
my      0.14307581     0.016188008
mz wsum=0
e     0.022624079   0.00022667312
bx     0.014965503   0.00022646554
by     0.018034518   0.00020733169
bz wsum=0
\end{verbatim}
The comparison shows the maximum difference divided by the sum of maximum 
absolute
values and the sum of absolute differences divided by the sum of absolute
values for each variable in {\bf w0} and {\bf w1}. If a variable is zero
everywhere both in {\bf w0} and {\bf w1}, the {\bf wsum=0} message is shown.
You can compare arbitrary 1, 2, 3 and 4 dimensional arrays as long as they 
have the same size.
The last dimension is interpreted as the variable index {\bf iw}.
E.g. you could compare two cuts of {\tt wreg} with
\begin{verbatim}
compare,wreg(0:20,2,*),wreg(0:20,3,*)}
\end{verbatim}
   or you can check if the data read from two files have the same grid
\begin{verbatim}
compare,x0,x1
\end{verbatim}
If the two files have different resolutions, the {\bf coarsen} 
function can be used. For example, if two solutions were obtained on 
100 x 50 and 300 x 150 grids, then 
\begin{verbatim}
rholow =w0(*,*,0)
rhohigh=coarsen(w1(*,*,0), 3)
print,total(abs(rholow-rhohigh))/100/50
\end{verbatim}
will give the average deviation in density. The coarsening is done in
finite volume sense, i.e. the fine cells within the coarsened cell are
averaged out. The {\bf coarsen} function works properly for
uniform Cartesian grids only. Pointwise values can be compared
with the use of the {\bf triplet} and {\bf quadruplet} functions 
(see section \ref{s-plot-part}).

One can also visualize the difference between two data files 
with the {\bf plot\_data} procedure (see next section) by setting
\begin{verbatim}
w=w1-w0
\end{verbatim}
   if the two files use the same grid, or
\begin{verbatim}
wreg=wreg1-wreg0
\end{verbatim}
if the files use different unstructured grids but they are 
interpolated onto the same regular grid.

\section{Plotting data with plot\_data and show\_data \label{s-plot_data}}

Once the data is read by {\bf read\_data} or {\bf animate\_data} you can plot 
functions of {\bf w} with
\begin{verbatim}
plot_data
\end{verbatim}
Alternatively, you can use
\begin{verbatim}
show_data
\end{verbatim}
to read (or re-read) the file and plot it immediately. In both cases
you will see some plotting parameters with their current values:
\begin{verbatim}
======= CURRENT PLOTTING PARAMETERS ================
ax,az=  30, 30, contourlevel= 30, velvector= 200, velspeed (0..5)= 5
multiplot= 0 (default), axistype (coord/cells)=coord, fixaspect=1
bottomline=3, headerline=0
\end{verbatim}
The plots are normally shown in physical coordinates, i.e.
{\bf axistype='coord'}, but the axes can also run in cell indices 
if {\bf axistype='cells'} is set (that works for structured grid only!).
If {\bf fixaspect=1} or -1 the aspect ratio of the plot will be the same
as the true aspect ratio of the two axes, while {\bf fixaspect=0} allows
the aspect ratio to adjust so that 
the plot fits into the plotting window tightly. The {\bf fixaspect=-1}
setting preserves the aspect ratio but it allows adjusting the spacing 
between rows and columns of subplots independent of the shape
of the plotting window (this can result in large margins).
The variables {\bf bottomline} and {\bf headerline} control the number
of values shown at the bottom from {\bf time, it, nx} and at the top 
from {\bf headline, nx}.
You can change these values explicitly (e.g. {\bf bottomline=0}), or change 
their default values in procedure {\bf set\_default\_values} in {\bf procedures.pro}. 
See sections \ref{s-plotmode} and \ref{s-plot-part} for more detail.

Now, you will be prompted 
for the name of function(s) and the corresponding plotting mode(s):
\begin{verbatim}
======= PLOTTING PARAMETERS =========================
wnames                     =  rho ux uy uz p bx by bz
func(s) (e.g. rho p m1;m2) ? rho uy
2D scalar: shade/surface/contour/contlabel/contfill/contbar/tv/tvbar
2D polar : polar/polarlabel/polarfill/polarbar
2D vector: stream/stream2/vector/velovect/ovelovect
plotmode(s)                ? default
plottitle(s) (e.g. B [G];J)=default
autorange(s) (y/n)         =y
GRID            INT       = Array(50, 50)
\end{verbatim}
The function(s) to be plotted are determined by the {\bf func}
string parameter, which is a list of function names separated by spaces.
The number of functions {\bf nfunc} is thus determined by the number of
function names listed in {\bf func}. 

For each function you may set the plotting mode with the {\bf plotmode} string.
If you give fewer plotting mode(s) than {\bf nfunc}, the rest of
the functions will use the last plotting mode given, in the above example
{\bf default}, which is 'contbar' for scalars and 'streamover' for vector valued
functions. This padding rule is used for all the arrays described 
by strings. See section~\ref{s-plotmode} for more details on plotting modes.

The {\bf plottitle} parameter is usually set to {\bf 'default'} which
means that the function name is used for the title, but you can set it
explicitly, e.g. {\bf plottitle='Density;Momentum'}. Here the 
separator character is a semicolon, thus the titles may contain spaces.
No titles are produced if {\bf plottitle=' '} is set.

For each function you may set the plotting range by hand or let IDL
calculate the minimum and maximum by itself. This is defined by
the {\bf autorange} string parameter, which is a list of 'y' and 'n'
characters, each referring to the respective function. If you set 'n'
for any of the variables, the {\bf fmin} and {\bf fmax} arrays have
to be set, e.g.
\begin{verbatim}
fmin=[1. ,-1.]
fmax=[1.1, 1.]
\end{verbatim}
IDL remembers the previous setting and uses it, unless the number
of functions are changed. You can always set fmin=0, fmax=0, and let
IDL prompt you for the values.

\section{Function names in string func \label{s-functions}}

The function names listed in the {\bf func} string can be any of 
the variable names listed in the string array {\bf wnames}, which is 
read from the header of the file, or any of the function name strings 
shown in the {\bf functiondef} array at the beginning of
{\bf funcdef.pro} (see section \ref{s-funcdef}), 
or any expression using the standard variable, 
coordinate and scalar parameter names and various constants:
\begin{verbatim}
x y z r
rho p ux uy uz uu u bx by bz bb b
xSI gamma gammae Mi Me Qi Qe clight rbody
mu0 mu0A c0 op0 oc0 rg0 di0 ld0
\end{verbatim}
Here "uu" and "bb" are the velocity and magnetic field squared, while
"u" and "b" are the velocity and magnetic field magnitudes, 
respectively. Note that "x ... b" are arrays, while  "gamma" is
a scalar.  For example the maximum Alfv\'en 
speed could be given as {\bf func='b/sqrt(rho*mu0A)'}, but this is already 
defined in funcdef.pro as 'calfven'. However, for a multifluid data
file, one can use a different density, e.g. 
\begin{verbatim}
func='b/sqrt({OpRho}*mu0A)'
\end{verbatim}
where mu0A is the vacuum permeability together with the unit conversion
factors.
Note that the OpRho variable (density of O+ ion) is not among the standard
arrays, but it can still be used by enclosing it with the curly brackets.

You may combine two function names with the {\bf ;} character representing
two components of a vector, 
e.g. {\bf ux;uy} or {\bf bx;bz}, which can either be plotted as a 
vectorfield by the {\bf velovect}, {\bf vector} and {\bf arrow} plot modes, 
or as streamlines or fieldlines, using the {\bf stream} plotting modes.
For other plotting modes the absolute value
$\sqrt{ux^2+uy^2}$ is plotted.
You can also put a minus sign in front of any function or variable
name, which will simply multiply the value of the rest of the string by $-$1. 
For example '-Ti' plots ($-$1)*temperature of ions. This is just a shorthand for
the general syntax '-{Ti}'.

\section{Plotting modes in string plotmode \label{s-plotmode}}

There are many plotting modes available. 
These can be listed in the {\bf plotmode} string for each function separated 
by spaces. If the number of plotting modes is less than the number of functions,
the last plotting mode is applied for the rest of the functions.

For 1D plots the following plotting modes are available: 
\begin{verbatim}
Plotmode   Horizontal axis     Vertical axis
-------------------------------------------------------
plot       linear              linear
plot_io    linear              logarithmic
plot_oi    logarithmic         linear
plot_oo    logarithmic         logarithmic
\end{verbatim}
The default value for plotmode is 'plot', which uses linear axes.
The names of these plotting modes are identical with the corresponding IDL
procedures.

For 2D data there are many more possibilities.
For scalar functions the main plotting modes are 
\begin{verbatim}
Plotmode   Parameters                Description
----------------------------------------------------------------------
contour    contourlevel/colorlevel   contourlines
cont       contourlevel/colorlevel   contourlines or color map
lonlatn    contourlevel/colorlevel   lon-lat grid for north polar cap
lonlatd    contourlevel/colorlevel   lon-lat grid for south polar cap
polar      contourlevel/colorlevel   polar plot
scatter                              scatter plot
shade      ax az                     shaded surface, height proportional to value
surface    ax az                     surface mesh, height proportional to value
tv                                   grid cells colored by value
\end{verbatim}
The parameters {\bf ax} and {\bf az} define the viewing angle,
while the {\bf contourlevel} and {\bf contourlevel} parameters
determines the number of contourlevel and colors, respectively.
The 'tv','surface' and 'shade' plotting modes
can be used for Cartesian grids only (or grids transformed to Cartesian).

For functions with two components (e.g. 'bx;bz') the following plotting
modes are available
\begin{verbatim}
Plotmode  Parameters  Description
-----------------------------------------------------------------
stream    velvector   stream/fieldlines at random/selected points
          velpos  
          velrandom

arrow     velvector   arrows of fixed length at random/selected positions
          velpos
          velrandom

vector    velvector   vectors at random/selected positions
          velpos  
          velspeed
          velrandom

velovect              vectors at every grid point

ovelovect             vectors at every grid point (for overplot)
\end{verbatim}
The {\bf velvector} parameter determines the number of arrows or
stream/fieldlines shown. By default the position of arrows/streamlines
is random. The positions can be fixed with the {\bf velpos} array
(see section \ref{s-plot-part} for details). 
During an animation the arrows can move from their initial position
parallel to the local velocity at a speed proportional to the magnitude
of the velocity and the {\bf velspeed} parameter. The maximum value
is the default {\tt velspeed=5}, while {\tt velspeed=0} does not allow
the arrows to move. When the arrows move, it may be necessary to 
reinitialize them with a random position periodically, otherwise the 
arrows may converge to a small part of the domain. Setting {\tt velrandom}
to a small positive integer value (e.g. 5) will reinitialize the
position of every 5th vector every 5 picture of the animation.

The 'velovect' and 'ovelovect' plotting modes 
can be used for Cartesian grids only.

The following options can be added to any of the above plotting modes:
\begin{verbatim}
Option  Description
---------------------------------------------------------------------
log     show the 10 based logarithm of the function if it is positive
over    overplot the previous function
noaxis  do not show the axes
#ctNNN  use color table NNN (NNN is an integer from 0 to 999)
#cNNN   use color NNN       (NNN is an integer from 0 to 255)
max     plot maximum of the last "nplotstore" snapshots
mean    plot average of the last "nplotstore" snapshots
\end{verbatim}

For 1D plots:
\begin{verbatim}
Option  Description
---------------------------------------------------------------------
dash    dashed line style
dot     dotted line style
time    vertical dashed line at current time (for log/sat files)
\end{verbatim}

For 2D plots:
\begin{verbatim}
Option  Description
---------------------------------------------------------------------
bar     fill contour plot and show colorbar (also for "tv")
fill    fill contour plot without colorbar
label   contour plot with labels
deg     angle in degrees for plolar plots
rad     angle in radians for polar plots
hour    angle in hour for polar plots
lgx     logarithmic X axis
lgy     logarithmic Y axis
body    show the spherical body with radius rBody as a black circle
grid    show grid points with plus signs
mesh    show the mesh (lines connecting grid points) for structured grid
map     draw a world map under the plot
usa     draw the USA map under the plot
irr     force triangulation for irregular (non-Cartesian) grid
white   draw vectors, stream lines and the grid/mesh with white lines
\end{verbatim}
Note that it makes no sense to overplot the grid for the 
{\tt surface} plotting mode, on the other hand {\tt plotmode='shademesh'}
will plot the shaded surface together with the mesh of 'surface'.
The radius of the body {\bf rBody} is usueally read from the 
scalar parameter named 'r' or 'rbody' in the data file, or it can be set
manually.

Here is an example for some more complex plotmode strings:
\begin{verbatim}
plotmode='contbargridlog streamwhiteoverbody'
\end{verbatim} 
will show the 10 based logarithm of the first scalar quantity with 
a color bar and the grid points, 
and overplot the second vector quantity with white streamlines
and a black body at the origin.

For any of the colored plotting modes ('shade', 'contfill', 'contbar', 
'polarfill', 'polarbar', 'tv', and 'tvbar') the colortable can be 
changed by one of the 
\begin{verbatim}
xloadct
loadct,3
loadct_bw,70,/reverse
makect,'red'
\end{verbatim}
commands. The {\tt xloadct} and {\tt loadct} commands are part of IDL, while
the {\tt loadct\_bw} and {\tt makect} procedure is defined in
{\bf procedures.pro}.
The {\tt loadct\_bw} takes the same arguments as {\tt loadct}, but it ensures
that the first and last colors are black/white depending on the background.
The /reverse argument swaps the order of colors.
When no argument is given for {\tt loadct} or {\tt makect}, 
all the available color tables are listed
and the choice can be made interactively.
If multiple color tables are needed, they can be loaded with the \#ctNNN
option. The color can be set with the \#cNNN option. 

Many characteristics of the plots can be adjusted with system variables.
Here is a partial list of these:
\begin{verbatim}
system variable     description
-------------------------------------------------------------------------
!p.charsize         overall character size
!p.psym             symbols instead of lines in 1D plot
!p.symsize          symbol size
!p.thick            thickness of lines in plots
!p.linestyle        line style in plots (0=solid, 1=dotted, 2=dashed...)
!x.title            title of the X axis
!x.charsize         X axis character size
!x.thick            thickness of the lines forming the X axis
!x.ticks            number of X axis tick marks
!x.tickv            positions of X axis tick marks
!x.tickname         strings at X axis tick marks
!x.minor            number of minor tickmarks
\end{verbatim}
The Y and Z axes are affected by the analogous !y. and !z. variables.

\section{Plotting part of the domain \label{s-plot-part}}

It is possible to plot a part of the simulation domain.
One way that works for both structured and unstructured grids is
to set the global system variables
\begin{verbatim}
!x.range=[-10.,10.]
!y.range=[-20.,-5.]
\end{verbatim}
This will work well for 'flat' plotting modes, like 'contour',
'contfill', etc. For unstructured grids which are not transformed
to a regular grid, it works for all the available plotting modes.
To switch back to the default maximum range, use
\begin{verbatim}
!x.range=0
!y.range=0
\end{verbatim}
When the data is transfored to a regular grids, the domain of transformation
can be limited by the {\bf xreglimits} array as described in section
\ref{s-transform}. 

For structured grids, there is a further option of limiting or coarsening
the plot domain, and/or reducing the dimensionality of the plot.
The {\bf cut} index array selects some part of the function(s)
determined by {\bf func}.
This is done {\em after} any grid transformation and {\em after} 
the functions are calculated so that derivatives can be properly taken 
by the {\bf funcdef} function.
The {\bf grid} index array is defined to help to construct
the {\bf cut} array, e.g. if the grid size is 100 times 100:
\begin{verbatim}
cut=grid(*,50:*)
plot_data
\end{verbatim}
will show the upper half of the domain. To eliminate the edges use
\begin{verbatim}
cut=grid(1:98,1:98)
\end{verbatim}
A cross section of the domain can be plotted by reducing
the number of dimensions of {\bf cut} relative to {\bf grid}:
\begin{verbatim}
cut=grid(*,50)
\end{verbatim}
will produce 1D plots of the cross section along the midline parallel to 
the first coordinate axis. For a 2D cut of 3D data, use for example
\begin{verbatim}
cut=grid(*,50,*)
\end{verbatim}
   The effect of the {\bf cut} array can be switched off by 
\begin{verbatim}
cut=0
\end{verbatim}
or by running {\bf set\_default\_values}.

The {\bf triplet} function provides an easy way to set the {\bf cut} 
index array to represent a coarser grid. This is particularly useful
for the {\bf velovect} plotting mode, which tends to draw too many tiny arrows.
The {\bf triplet} function can have 3, 6, 9, or 12 parameters depending on 
the number of dimensions, and each triplet describes a subset of the 
indices in the given direction. The three elements are the 
minimum, maximum, and stride (like in Fortran 90), e.g. 
\begin{verbatim}
filename='example2.out'
npict=10
read_data
func='ux;uy'
plotmode='velovect'
cut=triplet(0,49,2, 33,66,1)
plot_data
\end{verbatim}
will show every second cell in the {\bf x} direction and the middle third 
in the {\bf y} direction. Note that the maximum index value should be
the actual grid size$-$1 except for the last dimension, otherwise the 
indices will not be correct. This problem can be solved by the use of the 
{\bf quadruplet} function, which has four parameters per dimension:
size, minimum, maximum, and stride. To show a coarse 20$*$20 grid 
from the top left 40$*$40 part of the 50$*$50 grid use
\begin{verbatim}
cut=quadruplet(50,0,39,2, 50,10,49,2)
plot_data
\end{verbatim}
Another way to show velocity vectors at fixed positions is the use of 
the "vector" plotting mode after setting the number of vectors {\bf velvector} 
and the array of positions {\bf velpos(velvector,2)} containing the 
X and Y coordinates for each vector. In principle {\bf velpos} can
be defined as an arbitrary set of points.
For a simple coarsening of the original grid points, the triplet and 
quadruplet functions can be used again:
\begin{verbatim}
cut=grid(0:39,10:49)
velvector=20*13 & velpos=fltarr(velvector,2)
velpos(*,*)=x(quadruplet(50,1,39,2, 50,11,49,3, 2,0,1,1))
plot_data

cut=0
plotmode='vector'
velvector=25*25 & velpos=fltarr(velvector,2)
velpos(*,*)=x(triplet(0,49,2, 0,49,2, 0,1,1))
plot_data
\end{verbatim}
Note that the last 0,1,1 triplet and 2,0,1,1 quadruplet correspond to
the second dimension of {\bf velpos} that always runs from 
0 (X coordinate) to 1 (Y coordinate). This approach is very useful when 
the velocity vectors are shown together with plots of other functions 
that should not be coarsened. To use random positions again, 
set {\bf velpos=0}.
The {\bf velpos} array can also be used to position streamlines for 
plotmode='stream' and 'stream2'.

Finally the {\bf rcut} parameter can be used to cut out a circle around
the origin. While the {\bf body} modifier in the plotting mode simply covers
the circle, the {\bf rcut} removes all the data inside that radius,
so it has an effect on the range of values.

\section{Multiplot \label{s-multiplot}}

The number and arrangement of subplots is automatically set based 
on the number of files and and the number of functions. 
The default arrangement be can overriden by setting the
{\bf multiplot} array. The most complicated use has 4 elements
\begin{verbatim}
multiplot=[2,3,0,2]
\end{verbatim} 
gives 2 by 3 subplots filled in row-wise (3rd element is 0) 
starting with the 3rd subplot (4th element is 2). If the third element is 1,
the subplots are filled in column-wise. If the 4th element is not given 
\begin{verbatim}
multiplot=[2,3,0]
\end{verbatim} 
the plotting starts at the top left subplot, as usual. Even simpler
cases are handled by setting multiplot to a scalar value.
Setting {\bf multiplot=3} is identical with {\bf multiplot=[3,1,0]} 
(a single row of plots), {\bf multiplot=-3} is identical with 
{\bf multiplot=[1,3,1]} (a single column of plots), 
{\bf multiplot=-1} is a column of subplots based on the number 
functions and files, while {\bf multiplot=0} gives the default
behaviour (the number of rows and columns is about the same and
filled in row-wise).

The spacing between subplots can be adjusted with the
{\bf plot\_spacex} and {\bf plot\_spacey} variables.
The spacing is measured in character size (which depends on !p.charsize).
The default values are 3 for both, which is usually sufficient to
show the axis labels. Setting both to zero (and also fixaspect=0 or -1)
can result in tigthly packed plots. 

To save space, the axis labels and axis titles are normally only shown 
for the subplots are at the leftmost column or the bottom row.
Setting (some of) the {\bf showxtitle, showytitle, showxaxis, showyaxis} 
parameters to 1 can be used to force the X and/or Y axes and their title plotted
for all subplots.

Functions can be plot on top of each other by setting the {\bf multiplot}
array such that the number of subplots is smaller than the number of
functions times the number of files.  

To overplot functions, the most convenient approach
is to use the 'over' option in the plotmode string, for example
\begin{verbatim}
func='rho bx;by'
plotmode='contbar streamover'
plottitle='rho;B'
plot_data
func='p ux;uy'
plottitle='p;U'
plotmode='contfill arrowover'
plot_data
\end{verbatim}
The number of functions and the number of subplots can be any combination.
In 1D plots, the line style is varied for the different 
functions, so the curves can be distinguished.

\section{Plotting another snapshot \label{s-plot-another}}

If you type
\begin{verbatim}
show_data
\end{verbatim}
the data will be read and plotted again without any questions asked,
since IDL remembers the previous settings. 

If you want to read another frame, say the second, from the same file, type
\begin{verbatim}
npict=2
read_data
\end{verbatim}
You can change the {\bf func} and {\bf plotmode} variables the same way:
\begin{verbatim}
func='rho p'
plotmode='contour surface'
plot_data
\end{verbatim}
Note that we did not need to reread the data.
Other variables, all listed in the common blocks at the beginning of the
{\bf procedues.pro} file, can be set similarly.
If you set
\begin{verbatim}
doask=1
\end{verbatim}
the macros will ask for all the parameters to be confirmed by a simple
RETURN, or to be changed by typing a new value. Set {\bf doask=0} to
get the default behaviour, which is no confirmation asked.
To overplot previous plots without erasing the screen, set
\begin{verbatim}
noerase=1
\end{verbatim}
You can return to the default settings for all parameters by calling the
\begin{verbatim}
set_default_values
\end{verbatim}
procedure.

\section{Animation and plotting with animate\_data \label{s-animate}}

This general procedure can plot, save into image and video file(s), or animate 
(using IDL's Xinteranimate) different functions of data 
read from one or more files. If a single snapshot is read, the
plot is drawn without animation. In essence, {\bf animate\_data} combines
{\bf read\_data} and {\bf plot\_data} for any number of files and any number 
of snapshots.
\begin{verbatim}
animate_data
\end{verbatim}
will first prompt you for {\bf filename(s)} unless already given. 
Animating more than one input files in parallel is
most useful for comparing simulations with the same or very similar physics
using different methods or grid resolution. It is a good idea to save 
snapshots at the same {\it physical} time into the data files.
By default (if multiplot=0), 
the functions corresponding to the files will be plot columnwise
with the leftmost column belonging to the first file.
The headlines and the grid sizes will be shown in 
for each file separately above the corresponding columns
if {\bf headerline=2} is set.

The function(s) to be animated and the plotting mode(s) for the functions 
are determined by the same {\bf func, plotmode}, and {\bf plottitle} 
strings as for {\bf plot\_data}. To plot different functions, plot modes,
and/or plot titles per file, set the {\bf func\_file, plotmode\_file} and/or
{\bf plottitle\_file} string arrays with as many elements as the number of files.
If any part of the {\bf autorange} string is set to {\bf 'y'},
the data file(s) will be read twice: first for setting the common range(s) 
for all the snapshots and the second time for plotting.
If {\bf autorange='n'} the file(s) will only be read once.
Here is an example showing two cuts of a 3D simulation together:
\begin{verbatim}
   filename='y=0.outs z=0.outs'
   plottitle_file=['Density and velocity in y=0 plane', 'Density and U in z=0 plane']
   func_file=['rho ux;uz', 'rho ux;uy']
   plotmode_file=['contfill streamover', 'contbar streamover']
   showxtitle=1
   showytitle=1
   animate_data
\end{verbatim}
The {\bf showxtitle} and {\bf showytitle} logicals control if the axis labels are shown
for each subplot or not. The default is to show the X axis for the bottom row only
and the Y axis for the left column only. When the axes vary from file to file, it is best
to show the axis labels for each subplot.

The number of snapshots to be animated is limited by the end of 
file(s) and/or by the {\bf npictmax} parameter. With a formula
\begin{verbatim}
npict=min( npictmax, min( 1 + (npictinfiles-firstpict)/dpict ) )
\end{verbatim}
The animation runs from {\bf firstpict}, every {\bf dpict}-th picture is
plotted and the total number of animated frames is at most {\bf npictmax}. 
If {\bf firstpict} and {\bf dpict} are scalars, the same values are
applied for all the files, but it is also possible to use different
values for each file by setting array values, e.g. for two files
\begin{verbatim}
firstpict=[5,9]
dpict    =[1,2]
\end{verbatim}
will plot every frame starting from the 5th in the first file,
and every second frame from the 9th in the second file.

The {\bf multiplot} array can be used to get some really interesting
effects in {\bf animate\_data}: 
the data from multiple files can be overplotted for comparison purposes.
Probably it is a good idea to compare 1D slices rather than full 2D plots,
e.g. 
\begin{verbatim}
filename='example[12].out'
func='rho ux'
cut=grid(*,25)
multiplot=2
animate_data
\end{verbatim}
will overplot density and velocity read from the two files. 
The lines belonging to the two data files are distinguished by
the different line styles. For a 2D comparison, one could use
\begin{verbatim}
filename='example[12].out'
func='rho ux'
plotmode_file=['contfill', 'contour']
multiplot=2
animate_data
\end{verbatim}
Timeseries can also be produced easily with {\bf multiplot}. 
\begin{verbatim}
filename='example2.out'
func='rho ux;uy'
plotmode='contfill vectorover'
npictmax=6
multiplot=[3,2,0]
bottomline=1
animate_data
\end{verbatim}
will show the first 6 snapshots of density with overplot velocity vectors
in a single plot. 
Now the time is shown for each plot individually, and setting
{\bf bottomline=1} limits the time stamp to the most essential
information, time. The {\bf bottomline=2} shows the iteration number
and the time, while {\bf bottomline=3} also shows the grid size.
This information can be customized by setting {\bf bottomline} to
a string valued expression, e.g.
\begin{verbatim}
bottomline='"Time="+stime+", Grid="+snx+", Iteration="+sit'
\end{verbatim}
where {\bf stime, snx, sit} are formatted strings of time, iteration number
and grid size. An even more complicated example is to use expressions and
string formatting explicitly, e.g.
\begin{verbatim}
bottomline='"Time="+string(time*1e9,format="(f5.1)")+" ns"'
\end{verbatim}
that will show time in units of nanoseconds.

An alternative approach (that works with animate\_data only) is to set the 
{\bf timetitle} string to format the time and show it as the plot title.
For example
\begin{verbatim}
timetitle='("t=",f8.1,"s")'
\end{verbatim}
will show the time as {\bf t=240000.0s}. The time units and the
initial time (offset) can be set with {\bf timetitleunit} 
and {\bf timetitlestart}. For example
\begin{verbatim}
timetitleunit=3600.0
timetitlestart=60.0
timetitle='("t=",f5.2,"h")'
\end{verbatim}
will show the time as {\bf t= 6.67h}. Note that timetitleunit is
relative to the time units used in the data file (e.g. seconds)
while the offset is given in the time units defined by timetitleunit.

Set timetitle to an empty string and/or timetitleunit and timetitlestart
to zero to return to the default behavior. 
If {\bf npict*nfile*nplot} is greater than the number 
of subplots defined by {\bf multiplot}, an animation is done. 
Type 
\begin{verbatim}
multiplot=0
\end{verbatim}
to return to default behavior, which is one snapshot per plot.

Even after exiting from Xinteranimate, the animation can be repeated
again without rereading the data file(s) by typing
\begin{verbatim}
xinteranimate,/keep_pixmaps
\end{verbatim}
Sometimes it is interesting to visualize the difference of two runs, e.g.
to visualize deviations from the initial state, or from a steady state.
This can be achieved by setting the {\bf wsubtract} array, which will be 
subtracted from {\bf w} for each snapshot. Note that the subtraction is
done for the original variables in {\bf w}, 
so derived quantities should not be plotted. 
Set {\bf wsubtract=0} to switch off the subtraction.

The {\bf timediff=1} setting can be used to calculate the time
derivative by subtracting the previous plot data stored as {\bf wprev}
from the current one and dividing by the elapsed time {\bf time-timeprev}. 
Again, derived quantities may not be meaningful.
Set {\bf timediff=0} to switch off this feature.

The {\bf pictdiff=1} setting is similar to {\bf timediff=1}, but there is
no division by the time difference. This can be useful for looking at
the changes in a ``steady state'' run. Set {\bf pictdiff=0} to switch off this
feature.

Note that the {\bf wsubtract} and {\bf timediff} features are only 
used by "animate\_data", since a single snapshot can be easily 
manipulated explicitly, e.g. {\bf w=w1-w0}, before plotting with
{\bf plot\_data}. 

Even more access to the animated data is provided by the variables found in the
{\bf plot\_store} common block. Setting {\bf nplotstore}
to the number of snapshots to be stored, for example
\begin{verbatim}
nplotstore = npictmax
animate_data
help, plotstore, timestore
\end{verbatim}
will produce the four dimensional {\bf plotstore(n,nplotstore,nfunc,nfile)} array.
The first index is for the discrete points in the plotted functions in the
same order as in the {\bf w} or {\bf wreg} array.
The second index is for the snapshot (time), the third is for the
plot function (for multiple functions), and the last is the file index 
(for multiple files).
The times of the snapshots are saved into the {\bf timestore(nplotstore,nfilestore)}
array. 

Note that if the plot mode contain `max' or 'mean' option, the 
maximum or mean will be calculated for the last nplotstore snapshots,
but the plotstore array will still contain the original function values.

\section{Slicing structured 3D data \label{s-slice}}

For visualizing 3D data, plot\_data or animate\_data can be used after a
1 or 2D {\bf cut} array has been defined. Alternatively slices of a single
snapshot (read by read\_data) can be animated by
\begin{verbatim}
slice_data
\end{verbatim}
The 3D data is cut along {\bf slicedir}, e.g. for cuts parallel to the
X-Y plane, set
\begin{verbatim}
slicedir (1, 2, or 3)? 3
\end{verbatim}
If the grid size is e.g. 50$*$100$*$60, then there are 60 slices to plot.
The number of animated slices can be reduced:
at most {\bf nslicemax} slices are shown starting from {\bf firstslice},
and only every {\bf dslice}-th slice is shown.
The plots can be further reduced by setting the {\bf cut} array,
however, now indices in cut refer to a single slice. The {\bf grid2d} 
index array (generated by the first slice\_data, in this case it is a 50$*$100 
array) can be used, e.g.
\begin{verbatim}
cut=grid2d(*,30:70)
\end{verbatim}
For {\bf plotmode='vector'} the vectors are not advected with the flow 
(i.e. velspeed=0) since it does not make sense for the slices.

The x and w arrays are overwritten with the 2D cuts during the slicing,
and only restored to the 3D arrays at the end.
If the slicing failed for any reason, use
\begin{verbatim}
slice_data_restore
\end{verbatim}
to restore the arrays.

\section{Function definitions in funcdef \label{s-funcdef}}

The plot functions are set by the {\bf funcdef.pro} procedure.
This may be customized by the user. If it is modified, 
it should be recompiled before being used:
\begin{verbatim}
.r funcdef
\end{verbatim}
Any function of the variables in {\bf w}, the coordinates in
{\bf x}, the scalar parameters in {\bf eqpar} can be defined in the 
{\bf funcdef.pro} file. The names of these variables are defined
by the {\bf variables} string array.
Further information is provided by various
unit conversion constants set by the {\bf set\_units} procedure that
is usually called internally when the data file is read, 
but it can also be called directly, for example:
\begin{verbatim}
set_units,'PIC',distunit=0.01,Mion=16,Melectron=0.16
fixunits=1
\end{verbatim}
where the first argument sets the unit system
('SI', 'CGS', 'NORMALIZED', 'PIC', 'PLANETARY', or 'SOLAR')
which is normally guessed from the {\bf headerline} variable
of the data file;
the distance unit is given in meters (usually set by the xSI
scalar parameter in the data file); finally 
Mion and Melectron set the ion and electron masses in AMU
that may be defined by the Mi and Me scalar parameters.
All these arguments are optional.
The {\bf fixunits=1} ensures that the settings are not changed
when (re)reading a data file.

Once the units are properly set, many functions can be derived
from the basic variables. Here is a list of the currently 
defined functions (for vectors, only the X components are 
listed for sake of brevity):
\begin{verbatim}
Function name   Meaning
------------------------------------------------------------
Ax              vector potential X component
mx              momentum X component
mxB             Boris momentum X component
Ex              electric field X component -(u x B)_x
j               current density (from jx, jy, jz)
jpx             particle current density X component
jppar           particle current density parallel with B
jpperp          particle current density perpendicular to B
jpxbx           Lorentz force X component from particle current
divbxy          div(B) in 2D
divb1xy         div(B1) in 2D
uHx             Hall velocity X component (jx/ne)
uH              Hall velocity 
uex             electron velocity X component (ux-uHx)
ue              electron velocity
e               energy density p/(gamma-1)+0.5*(rho*uu + bb)
pbeta           plasma beta: p/(B^2/(2*mu0))
s               entropy: p/rho^gamma
ni              ion number density        
ne              electron number density   
qtot            total charge density
Ti              ion temperature: p/(n*k)
Te              electonr temperature: pe/(n*k)
uth             ion thermal speed
uthe            electron thermal speed
csound          sound speed: sqrt(gamma*p_thermal/rho)
cslowx          slow magnetosonic speed along X dimension
calfvenx        Alfven speed along X dimension: bx/sqrt(rho)
calfven         maximum of Alfven speed: |B|/sqrt(rho)
cfastx          fast magnetosonic speed along X dimension
cfast           maximum of fast speed: sqrt(csound^2+calfven^2)
machx           Mach number:  ux/csound
mach            Mach number: |u|/csound
Mslowx          slow Mach number along X dimension: ux/cslowx
Malfvenx        Alfven Mach number along X dim: ux/calfvenx
Malfven         maximum Alfven Mach number: |u|/calfven
Mfastx          fast Mach number along X dimension: ux/cfastx
Mfast           maximum fast Mach number: |u|/cfast
omegapi         ion plasma frequency                                 
omegape         electron plasma frequency
omegaci         ion gyro frequency        
omegace         electron gyro frequency 
rgyro           gyro radius               
rgSI            gyro radius in SI         
rgyroe          electron gyro radius      
rgeSI           electron gyro radius in SI
dinertial       inertial length           
diSI            ion inertial length in SI 
skindepth       electron skin depth       
deSI            electron skin depth in SI 
ldebye          Debye length              
ldSI            Debye length in SI        
\end{verbatim}

\section{Reading logfiles with read\_log\_data \label{s-getlog}}

One or more (at most ten) logfiles can be read by
\begin{verbatim}
read_log_data
\end{verbatim}
which reads data from the file(s) determined by the {\bf logfilename} 
parameter. This can be a space separated list of file names and/or it
may include wild card characters. The data in the
logfile(s) is put into the {\bf wlog} ({\bf wlog1, wlog2 ...}) real arrays,
while the names of the variables are put into the {\bf wlognames} 
({\bf wlognames1, wlognames2, ...}) string arrays. If the logfile contains
the variable names 't' or 'time', 'hour' or 'hours',
'yr mo dy hr mn sc ms' or 'year month day hour min sec msec', 
then the time is calculated and stored in the {\bf logtime} 
({\bf logtime1, logtime2, ...}) 1D real arrays. 
The time unit is defined by the {\bf timeunit} string
(possible values are {\bf 'h', 'm', 's', 'millisec', 'microsec', 'ns'});
the default units are hours. 
If no time variables are found, the {\bf logtime} array is set to the
row index.

After running {\bf read\_log\_data}, the {\bf wlog(nrow,ncol)} real array 
contains the rows and columns of the logfile, 
the {\bf wlognames(ncol)} string array the names and the
{\bf logtime(nrow)} array the times. A simple example is 
\begin{verbatim}
read_log_data
logfilename(s) =log_n020001.log
logfile  =log_n020001.log
headline =Volume averages, fluxes, etc
  wlog(*, 0)= it
  wlog(*, 1)= t
  wlog(*, 2)= dt
  wlog(*, 3)= rho
  wlog(*, 4)= mx
  wlog(*, 5)= my
  wlog(*, 6)= mz
  wlog(*, 7)= p
  wlog(*, 8)= bx
  wlog(*, 9)= by
  wlog(*,10)= bz
  wlog(*,11)= pmin
  wlog(*,12)= pmax
Number of recorded timesteps: nt=      1000
Setting logtime
\end{verbatim}
You can use the IDL plotting procedures directly to visualize the data, e.g.
\begin{verbatim}
plot,logtime,wlog(*,3),xtitle='hour',ytitle='rho_mean'
\end{verbatim}
checks the global mass conservation. 

The {\bf plot\_log\_data} procedure described next can be used to get 
much more sophisticated plots. 

\section{Plotting with plot\_log\_data or show\_log\_data \label{s-plotlog}}

Once the data in the logfile(s) have been read with {\bf read\_log\_data},
it can be easily visualized with the {\bf plot\_log\_data} procedure.
Alternatively, use
\begin{verbatim}
show_log_data
\end{verbatim}
to (re)read and plot the logfile data. 
The code will prompt for the names of the log functions that is
a space separated list of a subset of the strings in the wlognames array:
\begin{verbatim}
plot_log_data
logfunc(s)     ? mx pmin pmax
\end{verbatim}
To change the list of functions simply change the {\bf logfunc} string.
The spacing around the subplots (which are alway arranged vertically)
can be set with the {\bf log\_spacex} and {\bf log\_spacey} constants
given in character size (default values are 5 for both).

The time range of the plot can be set with the 2 element
{\bf xrange} array, while the vertical plot range for the individual functions 
can be set by the 2 by nfunc element {\bf yranges} array. For example
\begin{verbatim}
xrange=[10,20]
yranges=[[-10,10],[0,0.1],[0,100]]
\end{verbatim}
The default plot title, the X title (time) and the Y titles (log functions)
can be modified by setting the {\bf title} and {\bf xtitle} strings
and the {\bf ytitles} string array, respectively. For example
\begin{verbatim}
title='Simulation Results'
xtitle='Hours from October 29, 2003'
ytitles=['m!DX!N','P!Dmin!N','P!Dmax!N']
\end{verbatim}
To have no title at all, set these variables to empty strings.
For the default titles, set the variables to 0.

For multiple logfiles the plot\_log\_data procedure will overplot the data.
By default the lines belonging to the different data files are distinguished
by color, but it is possible to use different line styles or symbols
by setting the {\bf linestyles} or {\bf symbols} arrays. For example
\begin{verbatim}
colors=[255,255]
linestyles=[1,2]
symbols=[-4,-5]
\end{verbatim}
will show a dotted and a dashed line with the same default color
(usually white or black) and with diamonds and trianlges at
the data points, respectively.

The time coordinates can be shifted 
(towards the negative direction) by setting the {\bf timeshifts}
array which should have {\bf nlogfile} elements if set.
Set timeshifts=0 to get the default behavior.

It is possible to add legends to the plot by defining the {\bf legendpos}
array that contains the {\bf xmin, xmax, ymin, ymax} coordinates 
in normalized (0 to 1) coordinates. The legends consist of 
horizontal lines and/or symbols extending from xmin to xmax with the 
same colors, line types, and symbols as used for the data. 
Each horizontal line/symbol is followed by a string that is either
the name of the corresponding logfile, or the corresponding
element of the {\bf legends} string array consisting of {\bf nlog} strings.
For example
\begin{verbatim}
legendpos=[0.1,0.12,0.5,0.7]
\end{verbatim}
will draw horizontal lines from 0.1 to 0.12 with vertical coordinates
starting from 0.7 all the way down to 0.5. For symbols it is better
to use a single point, e.g.:
\begin{verbatim}
legendpos=[0.11,0.11,0.5,0.7]
\end{verbatim}
The horizontal lines or symbols will be foolowed by the file names by default.
Different legend strings can be given as
\begin{verbatim}
legends=['run1 with no AMR', $
         'run2 with 1 level of AMR', $
         'run2 with 2 levels of AMR']
\end{verbatim}
The legends can be switched off with 
\begin{verbatim}
legendpos=0
\end{verbatim}
The data can be smoothed with the {\bf smooths} array. 
The smoothing width can be defined for each logfile separately. 
A value less than 2 means that the data is not smoothed for that file.
For example
\begin{verbatim}
smooths=[100,0]
\end{verbatim}
will smooth the data from the first file only with a 100 point wide stencil.

Fourier transformation can also be performed by setting
\begin{verbatim}
dofft=1
\end{verbatim}
In this case the horizontal axis will be the frequency, and the
vertical axis will be the power spectrum of the log functions 
defined in {\bf logfunc}. The {\bf xrange} array 
can be used to select the relevant frequency range.

\section{Reading and plotting logfile data with read\_data and plot\_data}

While the {\bf read\_log\_data} and {\bf plot\_log\_data} procedures 
provide easy and flexible ways to plot data in logfiles, 
they do not allow to combine various columns
into new functions. One can work around this by reading the data
with {\bf read\_log\_data} first, then manipulate the {\bf wlog} array(s) 
directly, and then plot the modified data with {\bf plot\_log\_data}. 

An alternative approach is to use the {\bf read\_data} procedure to read
the logfile data into the {\bf x} and {\bf w} arrays:
\begin{verbatim}
read_data
filename(s)   =*.log
filetype(s)   = log
npictinfile(s)=       1
npict=       1
headline  =Volume averages, fluxes, etc
ndim      = 1, neqpar= 0, nw=13
it        =       0, time=      0.00000
nx        =     1182
eqpar     =      0.00000
variables = hour it t dt rho mx my mz bx by bz e Pmin Pmax
Read x and w
GRID            LONG      = Array[1182]
\end{verbatim}
The file type {\bf log} is recognized from the filename extension which
has to be {\bf '.log'} or {\bf '.sat'}. After reading the logfile,
the {\bf x} array contains the {\bf logtime} in hours 
(currently the timeunit is not adjustable in this approach), 
while the {\bf w} array will contain the various log functions. 
Now the logfile data can be plot as standard 1D data with {\bf plot\_data}.

\section{Saving plots into postscript and graphics files 
                \label{s-postscript}}

In IDL printing a plot is possible through Postscript files
using the {\bf set\_device} and {\bf close\_device} procedures.
\begin{verbatim}
set_device,'myfile.eps'
loadct,3
plot_data
close_device
\end{verbatim}
The first optional argument of the {\bf set\_device} procedure is the filename.
If it is not given, the default filename 'idl.ps' is used.
There are several keyword arguments too. Layout is set by 
{\tt /port} for portrait, {\tt /land} for landscape 
(this is the default, but in some cases it is needed)
and {\tt /square} for a square shaped figure.
The {\tt xratio} and {\tt yratio} options can be used
to shrink figure relative to the page size (default values are 1).
The {\tt /eps} option selects encapsulated postscript format (which is also
default if the file extension is .eps).
The {\tt psfont=12} argument can be used to select a specific font. 

With no arguments, the {\bf close\_device} procedure
simply closes the postscript device, and opens the 'X' device.
If the optional {\tt /pdf} argument is present, the output PostScript or EPS
file is converted to PDF using either the default {\tt ps2pdf} program 
or the programname given as a value, e.g. {\tt pdf='convert'}.
If the {\tt /delete} argument is present as well, the original PS or EPS file
is removed. 

You can use animate\_data instead of plot\_data (e.g. for multiple files or 
for time series) in combination with {\tt set\_device} and 
{\tt close\_device}, but make sure that only one plot is produced by setting
{\bf npictmax=1}, and use {\bf firstpict} to select the snapshot.
Here is an example showing many of the optional arguments:
\begin{verbatim}
npictmax=1
firstpict=12
set_device,'figure2.eps', /port, xratio=0.8, psfont=8
animate_data
close_device,pdf='convert',/delete
\end{verbatim}
This will produce a 'figure2.pdf' in portrait format with Helvetica font,
using the {\tt convert} program to convert to PDF.

To save all frames of an animation into a series of Postscript files, 
do not use {\bf set\_device} but set
\begin{verbatim}
savemovie='ps'
\end{verbatim}
This will produce files {\bf Movie/0001.ps,Movie/0002.ps,...} 
in the Movie directory, which is created automatically if it does
not exist. The PostScript files are best suited for printing.
You can also save the frames in PNG, TIFF, JPEG or BMP formats, e.g.
by setting 
\begin{verbatim}
savemovie='png'
\end{verbatim}
The frames can be put together into a movie by some program like
{\bf mpeg\_encode} or ImageMagick's {\bf convert}, or 
Apple's {\bf QuicktimePro7}, but there is a simpler approach.
To save the animation into a video file directly, 
use the 'mov', 'avi' or 'mp4' format. The name of the video file
can be set with 'videofile' (default name is 'movie') 
and the number of frames per second with 'videorate' (default is 10), 
for example
\begin{verbatim}
savemovie='mp4'
videofile='waterwaves'
videorate=24
animate_data
\end{verbatim}
will create 'waterwaves.mp4' file with 20 frames per second.

If you do not wish to use Xinteranimate, then set
\begin{verbatim}
showmovie='n'
\end{verbatim}
The default is 'y', so Xinteranimate is used if there are multiple frames.

\section{IDL scripts and procedures \label{s-idl-script}}

All the IDL commands can be collected into a script file, for example 
\begin{verbatim}
IDL_mine/myfig.pro
\end{verbatim}
which can be run from IDL by
\begin{verbatim}
@myfig
\end{verbatim}
This is a convenient way to store the commands for producing complicated 
figures. An example can be found in {\bf EXAMPLE.pro}. There are some
restrictions on scripts, however. Loops and other multi-line structures
cannot be used in a script. If loops are needed, simply add an 
{\bf end} statement to the end, and call it as
\begin{verbatim}
.r myfig
\end{verbatim}
For even more complicated cases a true procedure can be written.
The common variables can be imported through common blocks.
This can be called as any other procedure, for example
\begin{verbatim}
my_fig, inputfile='test.out', outputfile='test.eps'
\end{verbatim}

\end{document}
